<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TDID Live – Brel / Delta / Erasm.</title>
<style>
  :root{--bg:#0f1115;--fg:#eaeef5;--card:#141923;--line:#1e2330;--accent:#1a5bff}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  body{padding-top:64px}
  .top{position:fixed;top:0;left:0;right:0;height:64px;display:flex;gap:8px;align-items:center;padding:10px 12px;background:#12151bde;border-bottom:1px solid var(--line);backdrop-filter:blur(6px);z-index:10}
  .brand{font-weight:700;margin-right:8px}
  .btn{padding:8px 14px;border:1px solid var(--line);border-radius:12px;background:var(--card);color:var(--fg);cursor:pointer}
  .btn.active{background:var(--accent);color:#fff;border-color:transparent}
  .wrap{height:calc(100vh - 64px);display:flex;align-items:center;justify-content:center}
  img{max-width:100%;max-height:100%;object-fit:contain}
  .stamp{margin-left:auto;opacity:.9;font-size:.9em}
  .note{position:fixed;bottom:8px;left:50%;transform:translateX(-50%);opacity:.85;font-size:.85em;text-align:center;white-space:pre-line;max-width:92vw}
</style>
</head>
<body>
  <div class="top">
    <span class="brand">TDID Live</span>
    <button class="btn" id="brel">Brel</button>
    <button class="btn" id="delta">Delta</button>
    <button class="btn" id="erasme">Erasm.</button>
    <span class="stamp" id="stamp">—</span>
  </div>

  <div class="wrap"><img id="view" alt="TDID Live"></div>
  <div class="note" id="note"></div>

<script>
/* ====== CONFIG SP (ton code d’origine) ====== */
const SP_BASE   = "https://stibmivb-my.sharepoint.com/personal/florent_legrain_stib_brussels";
const SP_FOLDER = "/personal/florent_legrain_stib_brussels/Documents/LiveMirror";
function spRaw(file){
  const src = `${SP_FOLDER}/${file}`;
  return `${SP_BASE}/_layouts/15/download.aspx?SourceUrl=${encodeURIComponent(src)}`;
}
const DATA_SP = {
  brel:   { img: spRaw("live_brel.png")   },
  delta:  { img: spRaw("live_delta.png")  },
  erasme: { img: spRaw("live_erasme.png") }
};
const ERR_IMG_SP = spRaw("TDID_Erreur.png");

/* ====== CONFIG MIROIR (GitHub Pages) ====== */
const MIRROR_LATEST = "https://Flo-App-bxl.github.io/TDID-Live/mirror/latest.json";
const MIRROR_KEY = { brel: "brel", delta: "delta", erasme: "eras" };

/* Rafraîchissement & seuil (5 minutes) */
const REFRESH_MS = 3000;      // 3 s
const STALE_MS   = 300000;    // 5 min

/* ====== UI ====== */
const img   = document.getElementById('view');
const stamp = document.getElementById('stamp');
const note  = document.getElementById('note');
const btns  = { brel:document.getElementById('brel'), delta:document.getElementById('delta'), erasme:document.getElementById('erasme') };

let depot = localStorage.getItem('tdid_depot') || 'brel';
let lastBlobUrl = null;
let lastTsSeen = { brel:0, delta:0, erasme:0 }; // pour garantir "dernier" miroir
let lastSource = "—";

function setActive(){ for(const k in btns){ btns[k].classList.toggle('active', k===depot); } }
for(const k in btns){ btns[k].onclick = () => { depot=k; localStorage.setItem('tdid_depot', depot); setActive(); tick(true); }; }
setActive();

/* ====== Utils ====== */
const cb = u => u + (u.includes('?')?'&':'?') + 't=' + Date.now();

function setStampSource(srcLabel){
  lastSource = srcLabel;
  stamp.textContent = `${srcLabel} • ${new Date().toLocaleString()}`;
}

/* HEAD rapide pour valider la présence de l’image miroir (anti-lag CDN) */
async function headOk(url){
  try{
    const r = await fetch(cb(url), { method:'HEAD', cache:'no-store' });
    return r.ok;
  }catch(e){ return false; }
}

/* Charge latest.json avec anti-cache fort et re-try pour s’assurer d’avoir le + récent.
   - Réessaie jusqu’à 3x si (ts <= dernier ts vu) OU si HEAD de l’URL échoue. */
async function loadMirrorLatestStrong(key){
  let tries = 0, last = null;
  while (tries < 3){
    tries++;
    try{
      const r = await fetch(cb(MIRROR_LATEST), {cache:'no-store'});
      if (!r.ok) { await new Promise(res=>setTimeout(res, 300)); continue; }
      const j = await r.json();
      const item = j?.items?.[key];
      if (!item?.url || !Number.isFinite(item.ts)){ await new Promise(res=>setTimeout(res, 300)); continue; }

      // si ts pas plus récent que déjà vu → on retente (CDN lag)
      if (item.ts*1000 <= lastTsSeen[depot]){
        await new Promise(res=>setTimeout(res, 300));
        last = item; continue;
      }

      // Valide que l’image est vraiment dispo côté CDN
      const ok = await headOk(item.url);
      if (!ok){ await new Promise(res=>setTimeout(res, 300)); last = item; continue; }

      // OK : on enregistre le ts et on renvoie
      lastTsSeen[depot] = item.ts*1000;
      return item;
    }catch(e){
      await new Promise(res=>setTimeout(res, 300));
    }
  }
  // dernier recours : renvoyer le dernier lu (même s’il n’a pas passé toutes les vérifs)
  return last;
}

/* Affiche une image SP (direct) */
function showImageSP(src){
  return new Promise(resolve=>{
    img.onload  = ()=>{ setStampSource("SP"); resolve(true); };
    img.onerror = ()=>{ setStampSource("SP (image KO)"); resolve(false); };
    img.src = cb(src);
  });
}

/* Affiche une image miroir (blob, anti-cache) */
async function showImageMirror(url){
  try{
    const r = await fetch(cb(url), {cache:'no-store'});
    if (!r.ok) throw new Error('HTTP '+r.status);
    const blob = await r.blob();
    if (lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
    const u = URL.createObjectURL(blob);
    lastBlobUrl = u;
    return await new Promise(res=>{
      img.onload  = ()=>{ setStampSource("Miroir"); res(true); };
      img.onerror = ()=>{ setStampSource("Miroir (image KO)"); res(false); };
      img.src = u;
    });
  }catch(e){ return false; }
}

/* ====== Boucle principale ====== */
async function tick(force=false){
  const key = MIRROR_KEY[depot];
  const spImgUrl = DATA_SP[depot].img;
  let diag = `Dépôt: ${depot}\n`;

  // 1) On lit TOUJOURS l’âge du miroir (même si SP est accessible)
  const item = await loadMirrorLatestStrong(key);
  if (!item || !item.url || !Number.isFinite(item.ts)){
    // pas de miroir fiable → on tente quand même SP (mais sans contrôle d’âge)
    diag += "Miroir indisponible → tentative SP (sans âge)";
    const okSp = await showImageSP(spImgUrl);
    if (!okSp){
      img.src = ERR_IMG_SP;
      setStampSource("Erreur (miroir & SP indisponibles)");
      note.textContent = diag + "\n→ Erreur : sources indisponibles";
    } else {
      note.textContent = diag + "\nSP image OK (sans contrôle d’âge miroir)";
    }
    return;
  }

  const ageMs = Date.now() - (item.ts * 1000);
  const ageSec = Math.round(ageMs/1000);
  const stale = ageMs >= STALE_MS;
  diag += `Miroir age(ts) • Δ=${ageSec}s → ${stale ? 'STALE' : 'OK'}`;

  if (stale){
    // Exigence : si le DERNIER MIRROR a ≥ 5 min, on affiche l’erreur
    img.src = ERR_IMG_SP;
    setStampSource("Erreur (miroir en retard)");
    note.textContent = diag + "\n→ Erreur (origine : miroir en retard ≥ 5 min)";
    return;
  }

  // 2) Choix de la source d’image : SP en priorité, sinon Miroir
  // (on ne lit plus l’âge SP ; l’âge décisionnel est celui du miroir)
  const okSp = await showImageSP(spImgUrl);
  if (okSp){
    note.textContent = diag + "\nSP image OK • source: SP";
    return;
  }

  diag += "\nSP image KO → tentative Miroir";
  const okMir = await showImageMirror(item.url);
  if (okMir){
    note.textContent = diag + "\nMiroir image OK • source: Miroir";
  } else {
    img.src = ERR_IMG_SP;
    setStampSource("Erreur (miroir KO)");
    note.textContent = diag + "\n→ Erreur (origine : miroir indisponible)";
  }
}

setInterval(()=>tick(false), REFRESH_MS);
tick(true);
</script>
</body>
</html>
