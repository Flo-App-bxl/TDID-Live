<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TDID Live – Brel / Delta / Erasm.</title>
<style>
  :root{--bg:#0f1115;--fg:#eaeef5;--card:#141923;--line:#1e2330;--accent:#1a5bff}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  body{padding-top:64px}
  .top{position:fixed;top:0;left:0;right:0;height:64px;display:flex;gap:8px;align-items:center;padding:10px 12px;background:#12151bde;border-bottom:1px solid var(--line);backdrop-filter:blur(6px);z-index:10}
  .brand{font-weight:700;margin-right:8px}
  .btn{padding:8px 14px;border:1px solid var(--line);border-radius:12px;background:var(--card);color:var(--fg);cursor:pointer}
  .btn.active{background:var(--accent);color:#fff;border-color:transparent}
  .wrap{height:calc(100vh - 64px);display:flex;align-items:center;justify-content:center}
  img{max-width:100%;max-height:100%;object-fit:contain}
  .stamp{margin-left:auto;opacity:.85;font-size:.9em}
  .note{position:fixed;bottom:8px;left:50%;transform:translateX(-50%);opacity:.85;font-size:.85em;text-align:center;white-space:pre-line}
</style>
</head>
<body>
  <div class="top">
    <span class="brand">TDID Live</span>
    <button class="btn" id="brel">Brel</button>
    <button class="btn" id="delta">Delta</button>
    <button class="btn" id="erasme">Erasm.</button>
    <span class="stamp" id="stamp">—</span>
  </div>

  <div class="wrap"><img id="view" alt="TDID Live"></div>
  <div class="note" id="note"></div>

<script>
/* === Lecture directe RAW GitHub (instantané) === */
const RAW = "https://raw.githubusercontent.com/Flo-App-bxl/TDID-Live/main/";
const DATA = {
  brel:   { img: RAW + "live_brel.png",   age: RAW + "live_brel.age.txt"   },
  delta:  { img: RAW + "live_delta.png",  age: RAW + "live_delta.age.txt"  },
  erasme: { img: RAW + "live_erasme.png", age: RAW + "live_erasme.age.txt" }
};
const ERR_IMG    = RAW + "TDID_Erreur.png";
const REFRESH_MS = 3000;
const STALE_SEC  = 120; // ⏱ 2 minutes exactes

const img   = document.getElementById('view');
const stamp = document.getElementById('stamp');
const note  = document.getElementById('note');
const btns  = { brel:   document.getElementById('brel'),
                delta:  document.getElementById('delta'),
                erasme: document.getElementById('erasme') };

let depot = localStorage.getItem('tdid_depot') || 'brel';
let lastOk = 0;
let lastBlobUrl = null;
const lastAgeSeen = { brel:0, delta:0, erasme:0 };

function setActive(){ for (const k in btns) btns[k].classList.toggle('active', k===depot); }
for (const k in btns){ btns[k].onclick = ()=>{ depot=k; localStorage.setItem('tdid_depot', depot); setActive(); tick(true); }; }
setActive();

const bust = () => 't=' + Date.now();
const ver  = (base, v) => base + (base.includes('?')?'&':'?') + 'v=' + v + '&' + bust();

/* Timestamp → epoch ms ; corrige si epoch "local" (Excel/VBA) */
function normalizeEpoch(raw){
  let ms = Number(String(raw).trim());
  if (!Number.isFinite(ms)) return null;
  if (ms < 1e12) ms *= 1000;              // secondes -> ms
  const nowUtc = Date.now();
  if (ms - nowUtc > 10*60*1000) {         // semble futur => epoch local
    const offsetMin = new Date().getTimezoneOffset(); // UTC - local (souvent -60 / -120)
    ms = ms + offsetMin*60000;            // ✅ UTC = local + offset
  }
  return ms;
}

/* Lire age.txt (no-store) + heure serveur (header Date) */
async function readAge(url){
  try{
    const r = await fetch(url + (url.includes('?')?'&':'?') + bust(), {cache:'no-store'});
    if (!r.ok) return {ms:null, why:'HTTP '+r.status, serverNow:null};
    const serverNow = r.headers.get('Date') ? new Date(r.headers.get('Date')).getTime() : null;
    const ms = normalizeEpoch((await r.text()).trim());
    return {ms, why:null, serverNow};
  }catch{ return {ms:null, why:'fetch', serverNow:null}; }
}

/* Charger une image en blob (anti-cache CDN) */
async function loadImageNoStore(srcWithVersion){
  try{
    const r = await fetch(srcWithVersion, {cache:'no-store'});
    if (!r.ok) throw new Error('HTTP '+r.status);
    const blob = await r.blob();
    if (lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
    const url = URL.createObjectURL(blob);
    return url;
  }catch{ return null; }
}

async function tick(force=false){
  const {img:imgBase, age:ageUrl} = DATA[depot];
  let diag = `Depot: ${depot}\n`;

  // 1) Lire l'âge
  const info = await readAge(ageUrl);
  if (info.ms !== null){
    const nowRef = info.serverNow ?? Date.now();
    let dSec = Math.round((nowRef - info.ms)/1000);
    if (Math.abs(dSec) > 86400) dSec = Math.round((Date.now()-info.ms)/1000); // garde-fou 24h

    diag += `age.txt OK • Δ=${dSec}sec → ${dSec>=STALE_SEC ? 'STALE' : 'OK'}`;

    // 1a) trop vieux → écran erreur immédiat (à 120 s)
    if (dSec >= STALE_SEC){
      if (lastBlobUrl) { URL.revokeObjectURL(lastBlobUrl); lastBlobUrl = null; }
      img.src = ERR_IMG;
      stamp.textContent = "Hors service (≥2 min) • " + new Date().toLocaleString();
      note.textContent = diag + "\n→ Affichage Erreur";
      return;
    }

    // 1b) l'âge a changé → on charge l'image versionnée par cet age
    const ageChanged = info.ms !== lastAgeSeen[depot];
    const imgUrlV = ver(imgBase, info.ms); // 👈 URL unique par âge (= anti-cache dur)
    if (force || ageChanged){
      const blobUrl = await loadImageNoStore(imgUrlV);
      if (blobUrl){
        img.onload = ()=>{ lastOk = Date.now(); stamp.textContent = new Date().toLocaleString(); };
        img.onerror= ()=>{ stamp.textContent = "Erreur de chargement • " + new Date().toLocaleString(); };
        lastBlobUrl = blobUrl; img.src = blobUrl; lastAgeSeen[depot] = info.ms;
      }else if (!force && lastOk>0 && (Math.round((Date.now()-lastOk)/1000) >= STALE_SEC)){
        if (lastBlobUrl) { URL.revokeObjectURL(lastBlobUrl); lastBlobUrl = null; }
        img.src = ERR_IMG; diag += "\nimage KO → Erreur";
      }
    }
  } else {
    diag += `age.txt indisponible (${info.why}) • fallback sur image`;
    // fallback image avec cache-buster simple
    const blobUrl = await loadImageNoStore(DATA[depot].img + '?'+bust());
    if (blobUrl){ lastBlobUrl = blobUrl; img.src = blobUrl; lastOk = Date.now(); }
  }

  note.textContent = diag;
}

setInterval(()=>tick(false), REFRESH_MS);
tick(true);
</script>
</body>
</html>
